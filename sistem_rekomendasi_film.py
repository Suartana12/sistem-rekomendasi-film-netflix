# -*- coding: utf-8 -*-
"""Sistem Rekomendasi Film.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15mT69rKtDeWyYE_BYYNf6W-kvcTSHeSx

# **Proyek Machine Learning: Sistem Rekomendasi Film Netflix**
Proyek ini bertujuan untuk membangun sebuah model sistem rekomendasi film untuk platform Netflix, dengan menerapkan pendekatan Content-Based Filtering. Analisis ini akan membantu pengguna menemukan film baru yang sesuai dengan selera mereka, sehingga dapat meningkatkan pengalaman dan keterlibatan (engagement) pengguna.
"""

# Instal library Kaggle
!pip install -q kaggle

# Impor library untuk mengunggah file
from google.colab import files

# Buat direktori untuk menyimpan file kaggle.json
!mkdir -p ~/.kaggle

# Unggah file kaggle.json
print("Silakan unggah file kaggle.json Anda:")
uploaded = files.upload()

# Pindahkan file ke direktori yang benar dan atur izin
!mv kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

print("\nSetup Kaggle API selesai.")

"""## **Import Library**"""

# --- Library untuk Data Manipulation ---
import pandas as pd
import numpy as np
import json

# --- Library untuk Visualisasi Data ---
import seaborn as sns
import matplotlib.pyplot as plt

# --- Library untuk Machine Learning (Sistem Rekomendasi) ---
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity

# --- Library lainnya ---
import zipfile
import os

print("Semua library yang dibutuhkan telah berhasil diimpor.")

"""## **A. Data Loading**
Dataset yang digunakan adalah "Netflix Movies and TV Shows" dari Kaggle, yang berisi daftar film dan acara TV yang tersedia di Netflix.
"""

# Download dataset dari Kaggle
!kaggle datasets download -d shivamb/netflix-shows

# Ekstrak file zip yang telah diunduh
with zipfile.ZipFile('netflix-shows.zip', 'r') as zip_ref:
    zip_ref.extractall('netflix_dataset')

# Muat dataset ke dalam DataFrame pandas
df = pd.read_csv('netflix_dataset/netflix_titles.csv')

print("Dataset berhasil diunduh dan dimuat.")

# Tampilkan 5 baris pertama dari dataset
df.head()

# Tampilkan informasi ringkas mengenai dataset
df.info()

"""## **B. Exploratory Data Analysis (EDA)**
Pada tahap ini, dilakukan analisis lebih dalam menggunakan visualisasi data untuk menemukan pola dan wawasan dari dataset Netflix.

### **Analisis Kualitas Data**
"""

# Pengecekan Data Duplikat
duplicate_rows = df.duplicated().sum()
print(f"Jumlah baris duplikat dalam dataset: {duplicate_rows}")

# Pengecekan Nilai yang Hilang (Missing Values)
print("\nJumlah nilai hilang per kolom:")
print(df.isnull().sum())

"""### **Analisis Univariate: Distribusi Genre**"""

# Mengambil data genre dan memisahkannya
genres = df['listed_in'].str.split(', ', expand=True).stack()

# Menghitung frekuensi setiap genre
plt.figure(figsize=(12, 8))
sns.countplot(y=genres, order=genres.value_counts().index[:15], palette='viridis')
plt.title('Top 15 Genre Konten di Netflix', fontsize=16)
plt.xlabel('Jumlah Konten', fontsize=12)
plt.ylabel('Genre', fontsize=12)
plt.show()

"""### **Analisis Univariate: Distribusi Rating**"""

plt.figure(figsize=(12, 6))
sns.countplot(x='rating', data=df, order=df['rating'].value_counts().index, palette='magma')
plt.title('Distribusi Konten Berdasarkan Rating Usia', fontsize=16)
plt.xlabel('Rating', fontsize=12)
plt.ylabel('Jumlah Konten', fontsize=12)
plt.xticks(rotation=45)
plt.show()

"""## **C. Data Preparation**

### **Menangani Nilai yang Hilang dan Membuat DataFrame Baru**
"""

# Fokus pada tipe 'Movie' untuk rekomendasi film
df_movies = df[df['type'] == 'Movie'].copy()

# Mengisi nilai null pada kolom yang akan digunakan
features_to_fill = ['director', 'cast', 'country', 'rating', 'description']
for feature in features_to_fill:
    df_movies[feature] = df_movies[feature].fillna('')

# Membuat DataFrame baru yang hanya berisi kolom esensial
new_df = df_movies[['show_id', 'title', 'director', 'cast', 'listed_in', 'description']].copy()
new_df.rename(columns={'show_id': 'id', 'listed_in': 'genres'}, inplace=True)

new_df.head()

"""### **Pembersihan dan Penggabungan Fitur Teks**"""

# Fungsi untuk membersihkan dan menggabungkan teks
def clean_and_combine(row):
    # Menghapus spasi dan mengubah menjadi list
    director = [d.replace(" ", "") for d in row['director'].split(', ')]
    cast = [c.replace(" ", "") for c in row['cast'].split(', ')[:3]] # Ambil 3 pemeran utama
    genres = [g.replace(" ", "") for g in row['genres'].split(', ')]
    description = row['description'].split()

    # Gabungkan semua fitur menjadi satu list
    tags = director + cast + genres + description
    return " ".join(tags)

# Terapkan fungsi untuk membuat kolom 'tags'
new_df['tags'] = new_df.apply(clean_and_combine, axis=1)

# Membuat DataFrame akhir untuk pemodelan
final_df = new_df[['id', 'title', 'tags']]

# Reset indeks agar berurutan dari 0 hingga n-1
final_df.reset_index(drop=True, inplace=True)

final_df.head()

# Tampilkan contoh isi kolom 'tags' untuk satu film
print("Contoh isi kolom 'tags' untuk film pertama:\n")
print(final_df.iloc[0].tags)

"""## **D. Modeling and Result**

### **Model Pertama: Content-Based Filtering dengan TF-IDF**
"""

# Inisialisasi TfidfVectorizer
tfidf = TfidfVectorizer(max_features=5000, stop_words='english')

# Melakukan fit dan transform pada kolom 'tags'
vectors_tfidf = tfidf.fit_transform(final_df['tags']).toarray()

# Menghitung cosine similarity
similarity_tfidf = cosine_similarity(vectors_tfidf)

# Fungsi rekomendasi untuk model TF-IDF
def recommend_tfidf(movie_title):
    try:
        movie_index = final_df[final_df['title'] == movie_title].index[0]
    except IndexError:
        print(f"Film dengan judul '{movie_title}' tidak ditemukan.")
        return

    distances = similarity_tfidf[movie_index]
    movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x: x[1])[1:6]

    print(f"Rekomendasi film mirip '{movie_title}' (berdasarkan TF-IDF):")
    for i in movies_list:
        print(final_df.iloc[i[0]].title)

# Pengujian Model Pertama
recommend_tfidf('The Social Network')

"""### **Model Kedua: Content-Based Filtering dengan CountVectorizer**"""

# Inisialisasi CountVectorizer
count_vec = CountVectorizer(max_features=5000, stop_words='english')
vectors_bow = count_vec.fit_transform(final_df['tags']).toarray()

# Menghitung cosine similarity
similarity_bow = cosine_similarity(vectors_bow)

# Fungsi rekomendasi untuk model Bag of Words
def recommend_bow(movie_title):
    try:
        movie_index = final_df[final_df['title'] == movie_title].index[0]
    except IndexError:
        print(f"Film dengan judul '{movie_title}' tidak ditemukan.")
        return

    distances = similarity_bow[movie_index]
    movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x: x[1])[1:6]

    print(f"Rekomendasi film mirip '{movie_title}' (berdasarkan Bag of Words):")
    for i in movies_list:
        print(final_df.iloc[i[0]].title)

# Pengujian Model Kedua
recommend_bow('The Social Network')

"""## **E. Evaluation**

### **Langkah 1 & 2: Modifikasi Fungsi Rekomendasi & Membuat Fungsi Evaluasi**
"""

# Fungsi untuk mendapatkan list rekomendasi (TF-IDF)
def get_recommendations_tfidf(movie_title):
    try:
        movie_index = final_df[final_df['title'] == movie_title].index[0]
    except IndexError:
        return []
    distances = similarity_tfidf[movie_index]
    movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x: x[1])[1:6]
    return [final_df.iloc[i[0]].title for i in movies_list]

# Fungsi untuk mendapatkan list rekomendasi (Bag of Words)
def get_recommendations_bow(movie_title):
    try:
        movie_index = final_df[final_df['title'] == movie_title].index[0]
    except IndexError:
        return []
    distances = similarity_bow[movie_index]
    movies_list = sorted(list(enumerate(distances)), reverse=True, key=lambda x: x[1])[1:6]
    return [final_df.iloc[i[0]].title for i in movies_list]

# Fungsi untuk menghitung precision berdasarkan kesamaan genre
def calculate_precision(input_title, recommended_titles):
    try:
        # Menggunakan df_movies yang masih memiliki kolom 'listed_in' asli
        input_genres = set(df_movies[df_movies['title'] == input_title]['listed_in'].iloc[0].split(', '))
    except IndexError:
        print(f"Film input '{input_title}' tidak ditemukan.")
        return 0.0

    if not recommended_titles:
        return 0.0

    relevant_count = 0
    for title in recommended_titles:
        try:
            rec_genres = set(df_movies[df_movies['title'] == title]['listed_in'].iloc[0].split(', '))
            # Jika ada irisan genre, dianggap relevan
            if input_genres.intersection(rec_genres):
                relevant_count += 1
        except IndexError:
            continue

    return relevant_count / len(recommended_titles)

"""### **Langkah 3: Mengevaluasi Kinerja Kedua Model**"""

# Film yang akan diuji
test_movie = 'The Social Network'

# --- Evaluasi Model 1 (TF-IDF) ---
recs_tfidf = get_recommendations_tfidf(test_movie)
precision_tfidf = calculate_precision(test_movie, recs_tfidf)

print(f"Rekomendasi dari TF-IDF untuk '{test_movie}': {recs_tfidf}")
print(f"Precision @5 untuk model TF-IDF: {precision_tfidf:.2f}\n")

# --- Evaluasi Model 2 (Bag of Words) ---
recs_bow = get_recommendations_bow(test_movie)
precision_bow = calculate_precision(test_movie, recs_bow)

print(f"Rekomendasi dari Bag of Words untuk '{test_movie}': {recs_bow}")
print(f"Precision @5 untuk model Bag of Words: {precision_bow:.2f}")

"""## **Analisis Hasil Evaluasi**

Hasil pengujian pada film "The Social Network" (genre: Dramas, Independent Movies) menunjukkan perbedaan kinerja yang signifikan antara kedua model.

**Model 1: TF-IDF**

*   Rekomendasi: ['The Music of Silence', 'Nothing to Lose', 'The End of the Tour', 'Justin Timberlake + the Tennessee Kids', 'Tiffany Haddish: She Ready! From the Hood To Hollywood!']
*   Nilai Presisi: Model ini mencapai Precision@5 sebesar 0.60.

**Model 2: Bag of Words (CountVectorizer)**

*   Rekomendasi: ['Nothing to Lose', 'The Music of Silence', 'The End of the Tour', 'Ani... Dr. Kashinath Ghanekar', 'Curtiz']
*   Nilai Presisi: Model ini mencapai Precision@5 sebesar 1.00.

**Perbandingan dan Wawasan**

1.   Kinerja Model: Dalam kasus uji ini, model Bag of Words (CountVectorizer) secara jelas memberikan hasil yang lebih baik daripada model TF-IDF. Presisinya sempurna, menunjukkan relevansi genre yang lebih tinggi.
2.   Alasan Perbedaan Kinerja: Perbedaan ini kemungkinan besar disebabkan oleh cara kedua metode membobot kata. TF-IDF memberikan bobot lebih tinggi pada kata-kata yang jarang muncul di seluruh dokumen. Ada kemungkinan kata seperti "music" atau "stand-up" memiliki bobot TF-IDF yang tinggi dalam deskripsi atau tag film tertentu, yang mendorongnya ke atas dalam peringkat rekomendasi meskipun genrenya tidak cocok. Sebaliknya, CountVectorizer hanya menghitung frekuensi kata, sehingga fitur-fitur umum yang kuat seperti nama sutradara/aktor dan genre "Drama" lebih mendominasi perhitungan kemiripan, menghasilkan rekomendasi yang lebih konsisten secara tematik.

Secara keseluruhan, evaluasi ini menunjukkan bahwa untuk dataset dan kombinasi fitur ini, pendekatan yang lebih sederhana (Bag of Words) ternyata lebih efektif dalam menghasilkan rekomendasi yang relevan secara genre.
"""